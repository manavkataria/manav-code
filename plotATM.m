function plotATM(matName,infoName,signal)
%
% Version 1.0: Original form physioTools
% Version 1.1: plotATM.m modified to plot specific signals, 6th Sep 2010
% Version 1.2: plotATM.m Verify Einthoven's Triangle / 2 lead info sufficient.
%              Calculates the error of L2 obtained from L2 = L1 + L3, vs
%              Real world recorded L2; And AVL, AVR, AVF computed from
%              Enthoven's model Vs. Real world Recordings - Physiobank's PTBDB
%              6th Sep 2010
%
% usage: plotATM('RECORDm.mat', 'RECORDm.info',[1 3 5])
% Plots only signal number 1, 3 and 5.
%
% This function reads a pair of files generated by 'wfdb2mat' from a
% PhysioBank record, baseline-corrects and scales the time series
% contained in the .mat file, and plots them.  The baseline-corrected
% and scaled time series are the rows of matrix 'val', and each
% column contains simultaneous samples of each time series.
%
% 'wfdb2mat' is part of the open-source WFDB Software Package available at
%    http://physionet.org/physiotools/wfdb.shtml
% If you have installed a working copy of 'wfdb2mat', run a shell command
% such as
%    wfdb2mat -r 100s -f 0 -t 10 >100sm.info
% to create a pair of files ('100sm.mat', '100sm.info') that can be read
% by this function.
%
% The files needed by this function can also be produced by the
% PhysioBank ATM, at
%    http://physionet.org/cgi-bin/ATM
%

% plotATM.m           O. Abdala			16 March 2009

  Octave = exist('OCTAVE_VERSION');
  load(matName);
  fid = fopen(infoName, 'rt');
  fgetl(fid);
  fgetl(fid);
  fgetl(fid);
  [freqint] = sscanf(fgetl(fid),'Sampling frequency: %f Hz  Sampling interval: %f sec');
  interval = freqint(2);
  fgetl(fid);
  signalIndex=1;
  if(Octave)
    for i=1:size(val,1)
      R=split(fgetl(fid),char(9));
      signalName{i} = R(2,:);
      gain(i) = str2num(R(3,:));
      base(i) = str2num(R(4,:));
      units{i} = R(5,:);
    end
  else
    for i=1:size(val,1)
      if (i==signal(signalIndex))
          [row(signalIndex), signalName(signalIndex), gain(signalIndex), base(signalIndex), units(signalIndex)]=strread(fgetl(fid),'%d%s%f%f%s','delimiter','\t');
          signalIndex = signalIndex+1;
      else
          % Dummy read to increment the file pointer.
          [row(signalIndex), signalName(signalIndex), gain(signalIndex), base(signalIndex), units(signalIndex)]=strread(fgetl(fid),'%d%s%f%f%s','delimiter','\t');
      end
      if (signalIndex > length(signal)) break; end;              
    end
  end
  fclose(fid);
  val(val==-32768) = NaN;
  signalIndex=1;
  valfiltered(signalIndex,:) = zeros(1,size(val,2));
  for i=1:size(val,1)
      if (i==signal(signalIndex))
            valfiltered(signalIndex,:) = (val(i,:)-base(signalIndex))/gain(signalIndex);
            signalIndex = signalIndex+1;
       end
       if (signalIndex > length(signal)), break; end;              
  end
  x = (1:size(val,2))*interval;

%  plot(x',valfiltered'); 
%% Verifying Einthoven's Theory: Triangle Vs Real world signals 
  % test using: plotATM('s0014lrem.mat','sc.info',[1 2 3 4 5 6]);
  % Compute Derived Leads:
  valeinth(1,:) = valfiltered(1,:)+valfiltered(3,:);  %Lead2
  valeinth(2,:) = -(valfiltered(1,:)+valfiltered(2,:))/2;  %Lead aVR
  valeinth(3,:) = (valfiltered(1,:)-valfiltered(3,:))/2;  %Lead aVL
  valeinth(4,:) = (valfiltered(2,:)+valfiltered(3,:))/2;  %Lead aVF
  
  % Compute Errors Real - Derived:
  figure; plot(x',(valfiltered(2,:) - valeinth(1,:))','r'); % Error for Lead 2;
  figure; plot(x',(valfiltered(4,:) - valeinth(2,:))','r'); % Error for Lead aVR;
  figure; plot(x',(valfiltered(5,:) - valeinth(3,:))','r'); % Error for Lead aVL;
  figure; plot(x',(valfiltered(6,:) - valeinth(4,:))','r'); % Error for Lead aVF;

  for i=1:length(signal), labels{i}=strcat(signalName{i},' (',units{i},')'); end
  legend(labels);
  xlabel('Time (sec)');
end
